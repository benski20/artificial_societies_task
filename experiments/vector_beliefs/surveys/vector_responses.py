"""
Probabilistic response generation via projection onto belief vector.

Responses are generated by:
1. Projecting question/option embeddings onto persona's belief vector
2. Calculating similarity (dot product)
3. Using softmax to get probability distribution
4. Sampling probabilistically
"""

import numpy as np
from typing import Dict, List, Optional, Tuple
import sys
from pathlib import Path

# Add project root to path
project_root = Path(__file__).parent.parent.parent.parent
sys.path.insert(0, str(project_root))

from experiments.vector_beliefs.persona.vector_persona import VectorPersona
from experiments.vector_beliefs.surveys.question_embeddings import QuestionEmbedder
from surveys.questions import SURVEY_QUESTIONS


def project_onto_belief_vector(question_vector: np.ndarray,
                               belief_vector: np.ndarray) -> float:
    """
    Project question vector onto belief vector.
    
    Uses cosine similarity (dot product after normalization).
    
    Args:
        question_vector: Question/option vector in belief space
        belief_vector: Persona's belief vector
        
    Returns:
        Projection score (similarity)
    """
    # Normalize vectors
    q_norm = question_vector / (np.linalg.norm(question_vector) + 1e-8)
    b_norm = belief_vector / (np.linalg.norm(belief_vector) + 1e-8)
    
    # Dot product (cosine similarity)
    similarity = np.dot(q_norm, b_norm)
    
    return float(similarity)


def calculate_response_probabilities(persona: VectorPersona,
                                    question_id: str,
                                    question_embedder: QuestionEmbedder,
                                    temperature: float = 1.0) -> Tuple[np.ndarray, List[str]]:
    """
    Calculate probability distribution over response options.
    
    Args:
        persona: Persona with belief vector
        question_id: Question identifier
        question_embedder: Question embedder
        temperature: Temperature for softmax (higher = more uniform)
        
    Returns:
        Tuple of (probabilities, option_labels)
    """
    belief_vector = persona.get_belief_vector()
    
    # Get option vectors in belief space
    option_vectors = question_embedder.get_option_belief_vectors(question_id)
    options = list(option_vectors.keys())
    
    # Calculate projection scores for each option
    scores = []
    for option in options:
        option_vector = option_vectors[option]
        score = project_onto_belief_vector(option_vector, belief_vector)
        scores.append(score)
    
    scores = np.array(scores)
    
    # Apply temperature scaling
    scaled_scores = scores / temperature
    
    # Softmax to get probabilities
    exp_scores = np.exp(scaled_scores - np.max(scaled_scores))  # Numerical stability
    probabilities = exp_scores / np.sum(exp_scores)
    
    return probabilities, options


def generate_vector_response(persona: VectorPersona,
                            question_id: str,
                            question_embedder: QuestionEmbedder,
                            temperature: float = 1.0,
                            random_state: Optional[np.random.Generator] = None) -> str:
    """
    Generate probabilistic response to survey question.
    
    Args:
        persona: Persona with belief vector
        question_id: Question identifier
        question_embedder: Question embedder
        temperature: Temperature for softmax
        random_state: Random number generator
        
    Returns:
        Selected response option
    """
    if random_state is None:
        random_state = np.random.default_rng()
    
    # Calculate probabilities
    probabilities, options = calculate_response_probabilities(
        persona, question_id, question_embedder, temperature
    )
    
    # Store probabilities
    persona.response_probabilities[question_id] = probabilities
    
    # Sample response
    selected_idx = random_state.choice(len(options), p=probabilities)
    selected_response = options[selected_idx]
    
    # Store response
    persona.survey_responses[question_id] = selected_response
    
    return selected_response


def generate_all_responses(personas: List[VectorPersona],
                          question_embedder: QuestionEmbedder,
                          question_ids: Optional[List[str]] = None,
                          temperature: float = 1.0,
                          random_seed: Optional[int] = None) -> List[VectorPersona]:
    """
    Generate responses for all personas to all questions.
    
    Args:
        personas: List of personas
        question_embedder: Question embedder
        question_ids: List of question IDs (default: all questions)
        temperature: Temperature for softmax
        random_seed: Random seed
        
    Returns:
        Updated personas with responses
    """
    if question_ids is None:
        question_ids = question_embedder.get_all_question_ids()
    
    if random_seed is not None:
        rng = np.random.default_rng(random_seed)
    else:
        rng = np.random.default_rng()
    
    for persona in personas:
        for question_id in question_ids:
            generate_vector_response(
                persona, question_id, question_embedder,
                temperature=temperature, random_state=rng
            )
    
    return personas

